#pragma once
/**
 * @file OBJLoader.h
 * @brief Simple Wavefront .OBJ mesh file loader.
 *
 * Supports:
 *   v  — vertex positions
 *   vt — texture coordinates
 *   vn — vertex normals
 *   f  — faces (triangles and quads, auto-triangulated)
 *
 * Face formats supported:
 *   f v1 v2 v3                     (position only)
 *   f v1/vt1 v2/vt2 v3/vt3        (position + texcoord)
 *   f v1/vt1/vn1 v2/vt2/vn2 ...   (position + texcoord + normal)
 *   f v1//vn1 v2//vn2 v3//vn3     (position + normal, no texcoord)
 */

#include "Mesh.h"

#include <cmath>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

namespace qe {
namespace renderer {

class OBJLoader {
public:
    struct RawMesh {
        std::vector<float> positions;   // x, y, z (groups of 3)
        std::vector<float> texcoords;   // u, v (groups of 2)
        std::vector<float> normals;     // x, y, z (groups of 3)

        struct FaceVertex {
            int pos_idx = -1;
            int tex_idx = -1;
            int norm_idx = -1;
        };
        std::vector<FaceVertex> face_verts;  // Triangulated face vertices
    };

    /** Load an OBJ file and return a renderable Mesh. */
    static Mesh load(const std::string& path,
                     float r = 0.7f, float g = 0.7f, float b = 0.7f) {
        RawMesh raw;
        if (!parse_file(path, raw)) {
            std::cerr << "[OBJ] Failed to load: " << path << std::endl;
            return Mesh();
        }

        return build_mesh(raw, r, g, b);
    }

    /** Write a simple OBJ file for a given set of vertices and faces. */
    static bool write_obj(const std::string& path,
                          const std::vector<Vertex>& vertices,
                          const std::vector<unsigned int>& indices) {
        std::ofstream file(path);
        if (!file.is_open()) return false;

        file << "# Generated by QuatEngine\n";
        for (const auto& v : vertices) {
            file << "v " << v.position[0] << " " << v.position[1]
                 << " " << v.position[2] << "\n";
        }
        for (const auto& v : vertices) {
            file << "vn " << v.normal[0] << " " << v.normal[1]
                 << " " << v.normal[2] << "\n";
        }
        for (const auto& v : vertices) {
            file << "vt " << v.uv[0] << " " << v.uv[1] << "\n";
        }
        for (size_t i = 0; i + 2 < indices.size(); i += 3) {
            // OBJ indices are 1-based
            file << "f "
                 << indices[i]+1 << "/" << indices[i]+1 << "/" << indices[i]+1 << " "
                 << indices[i+1]+1 << "/" << indices[i+1]+1 << "/" << indices[i+1]+1 << " "
                 << indices[i+2]+1 << "/" << indices[i+2]+1 << "/" << indices[i+2]+1 << "\n";
        }

        return true;
    }

private:
    static bool parse_file(const std::string& path, RawMesh& raw) {
        std::ifstream file(path);
        if (!file.is_open()) return false;

        std::string line;
        while (std::getline(file, line)) {
            if (line.empty() || line[0] == '#') continue;

            std::istringstream iss(line);
            std::string prefix;
            iss >> prefix;

            if (prefix == "v") {
                float x = 0, y = 0, z = 0;
                iss >> x >> y >> z;
                raw.positions.push_back(x);
                raw.positions.push_back(y);
                raw.positions.push_back(z);
            } else if (prefix == "vt") {
                float u = 0, v = 0;
                iss >> u >> v;
                raw.texcoords.push_back(u);
                raw.texcoords.push_back(v);
            } else if (prefix == "vn") {
                float x = 0, y = 0, z = 0;
                iss >> x >> y >> z;
                raw.normals.push_back(x);
                raw.normals.push_back(y);
                raw.normals.push_back(z);
            } else if (prefix == "f") {
                std::vector<RawMesh::FaceVertex> face;
                std::string token;
                while (iss >> token) {
                    face.push_back(parse_face_vertex(token));
                }
                // Triangulate (fan from first vertex)
                for (size_t i = 1; i + 1 < face.size(); ++i) {
                    raw.face_verts.push_back(face[0]);
                    raw.face_verts.push_back(face[i]);
                    raw.face_verts.push_back(face[i + 1]);
                }
            }
        }

        std::cout << "[OBJ] Loaded " << path << ": "
                  << raw.positions.size() / 3 << " verts, "
                  << raw.face_verts.size() / 3 << " tris" << std::endl;
        return true;
    }

    static RawMesh::FaceVertex parse_face_vertex(const std::string& token) {
        RawMesh::FaceVertex fv;

        // Count slashes
        size_t s1 = token.find('/');
        if (s1 == std::string::npos) {
            // Just position index
            fv.pos_idx = std::stoi(token) - 1;
            return fv;
        }

        size_t s2 = token.find('/', s1 + 1);

        // Position
        fv.pos_idx = std::stoi(token.substr(0, s1)) - 1;

        // Texcoord (may be empty for v//vn format)
        std::string tc_str = token.substr(s1 + 1, s2 - s1 - 1);
        if (!tc_str.empty()) {
            fv.tex_idx = std::stoi(tc_str) - 1;
        }

        // Normal
        if (s2 != std::string::npos) {
            std::string n_str = token.substr(s2 + 1);
            if (!n_str.empty()) {
                fv.norm_idx = std::stoi(n_str) - 1;
            }
        }

        return fv;
    }

    static Mesh build_mesh(const RawMesh& raw, float r, float g, float b) {
        Mesh mesh;
        std::vector<Vertex> vertices;
        std::vector<unsigned int> indices;

        for (size_t i = 0; i < raw.face_verts.size(); ++i) {
            const auto& fv = raw.face_verts[i];
            Vertex vert{};

            // Position
            if (fv.pos_idx >= 0 && fv.pos_idx * 3 + 2 < static_cast<int>(raw.positions.size())) {
                vert.position[0] = raw.positions[fv.pos_idx * 3 + 0];
                vert.position[1] = raw.positions[fv.pos_idx * 3 + 1];
                vert.position[2] = raw.positions[fv.pos_idx * 3 + 2];
            }

            // Normal
            if (fv.norm_idx >= 0 && fv.norm_idx * 3 + 2 < static_cast<int>(raw.normals.size())) {
                vert.normal[0] = raw.normals[fv.norm_idx * 3 + 0];
                vert.normal[1] = raw.normals[fv.norm_idx * 3 + 1];
                vert.normal[2] = raw.normals[fv.norm_idx * 3 + 2];
            } else {
                // Default up normal if missing
                vert.normal[0] = 0; vert.normal[1] = 1; vert.normal[2] = 0;
            }

            // Texcoord
            if (fv.tex_idx >= 0 && fv.tex_idx * 2 + 1 < static_cast<int>(raw.texcoords.size())) {
                vert.uv[0] = raw.texcoords[fv.tex_idx * 2 + 0];
                vert.uv[1] = raw.texcoords[fv.tex_idx * 2 + 1];
            }

            // Color
            vert.color[0] = r;
            vert.color[1] = g;
            vert.color[2] = b;

            vertices.push_back(vert);
            indices.push_back(static_cast<unsigned int>(i));
        }

        // Compute face normals for faces that didn't have normals
        if (raw.normals.empty()) {
            compute_face_normals(vertices, indices);
        }

        mesh.upload(vertices, indices);
        return mesh;
    }

    static void compute_face_normals(std::vector<Vertex>& vertices,
                                      const std::vector<unsigned int>& indices) {
        for (size_t i = 0; i + 2 < indices.size(); i += 3) {
            Vertex& v0 = vertices[indices[i]];
            Vertex& v1 = vertices[indices[i + 1]];
            Vertex& v2 = vertices[indices[i + 2]];

            float e1x = v1.position[0] - v0.position[0];
            float e1y = v1.position[1] - v0.position[1];
            float e1z = v1.position[2] - v0.position[2];
            float e2x = v2.position[0] - v0.position[0];
            float e2y = v2.position[1] - v0.position[1];
            float e2z = v2.position[2] - v0.position[2];

            float nx = e1y * e2z - e1z * e2y;
            float ny = e1z * e2x - e1x * e2z;
            float nz = e1x * e2y - e1y * e2x;

            float len = std::sqrt(nx * nx + ny * ny + nz * nz);
            if (len > 1e-6f) {
                nx /= len; ny /= len; nz /= len;
            }

            v0.normal[0] = v1.normal[0] = v2.normal[0] = nx;
            v0.normal[1] = v1.normal[1] = v2.normal[1] = ny;
            v0.normal[2] = v1.normal[2] = v2.normal[2] = nz;
        }
    }
};

} // namespace renderer
} // namespace qe
