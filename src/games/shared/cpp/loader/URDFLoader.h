#pragma once
/**
 * @file URDFLoader.h
 * @brief Minimal URDF XML parser for loading articulated humanoid models.
 *
 * Parses URDF files generated by the humanoid_character_builder to extract:
 *   - Link hierarchy (body segments)
 *   - Joint connections and offsets
 *   - Mesh file references (STL paths)
 *   - Material colors
 *
 * This is NOT a full URDF parser — it handles the subset produced by
 * HumanoidURDFGenerator: box/cylinder/sphere primitives and mesh references.
 *
 * Design by Contract:
 *   - Precondition: file_path is a valid URDF XML file
 *   - Postcondition: returned URDFModel has at least one link
 */

#include "../math/Quaternion.h"
#include "../math/Vec3.h"

#include <algorithm>
#include <cmath>
#include <fstream>
#include <map>
#include <sstream>
#include <string>
#include <vector>

namespace qe {
namespace loader {

// ── Data Structures ─────────────────────────────────────────────────────────

/** RGB color from URDF material. */
struct URDFColor {
  float r = 0.5f, g = 0.5f, b = 0.5f, a = 1.0f;
};

/** Geometry type for a URDF link. */
enum class URDFGeomType { Box, Cylinder, Sphere, Mesh };

/** Geometry description. */
struct URDFGeometry {
  URDFGeomType type = URDFGeomType::Box;
  // Box: size (x, y, z half-extents)
  math::Vec3 size{0.1f, 0.1f, 0.1f};
  // Cylinder/Sphere: radius + length
  float radius = 0.05f;
  float length = 0.2f;
  // Mesh: file path
  std::string mesh_filename;
};

/** Origin (position + rotation) for visual/collision/joint. */
struct URDFOrigin {
  math::Vec3 xyz{0, 0, 0};
  math::Vec3 rpy{0, 0, 0}; // Roll, Pitch, Yaw in radians
};

/** A URDF link (body segment). */
struct URDFLink {
  std::string name;
  URDFGeometry visual_geom;
  URDFOrigin visual_origin;
  URDFColor color;
  float mass = 1.0f;
};

/** A URDF joint (connection between links). */
struct URDFJoint {
  std::string name;
  std::string type; // "revolute", "fixed", "continuous"
  std::string parent_link;
  std::string child_link;
  URDFOrigin origin;
  math::Vec3 axis{0, 0, 1};
};

/** Complete parsed URDF model. */
struct URDFModel {
  std::string name;
  std::vector<URDFLink> links;
  std::vector<URDFJoint> joints;
  std::map<std::string, int> link_index; // name → index into links[]

  /** Get the root link (not a child of any joint). */
  std::string root_link_name() const {
    std::map<std::string, bool> is_child;
    for (const auto &j : joints) {
      is_child[j.child_link] = true;
    }
    for (const auto &l : links) {
      if (is_child.find(l.name) == is_child.end()) {
        return l.name;
      }
    }
    return links.empty() ? "" : links[0].name;
  }

  /** Get all children of a given link. */
  std::vector<const URDFJoint *>
  children_of(const std::string &link_name) const {
    std::vector<const URDFJoint *> result;
    for (const auto &j : joints) {
      if (j.parent_link == link_name) {
        result.push_back(&j);
      }
    }
    return result;
  }
};

// ── Results ─────────────────────────────────────────────────────────────────

struct URDFLoadResult {
  bool success = false;
  URDFModel model;
  std::string error;
  std::string base_dir; // Directory containing the URDF (for mesh paths)
};

// ── Parser ──────────────────────────────────────────────────────────────────

class URDFLoader {
public:
  /**
   * Load and parse a URDF file.
   * @param file_path  Path to the .urdf file.
   * @return URDFLoadResult with parsed model data.
   */
  static URDFLoadResult load(const std::string &file_path) {
    URDFLoadResult result;

    std::ifstream file(file_path);
    if (!file.is_open()) {
      result.error = "Cannot open URDF file: " + file_path;
      return result;
    }

    // Extract base directory for resolving mesh paths
    auto last_slash = file_path.find_last_of("/\\");
    result.base_dir = (last_slash != std::string::npos)
                          ? file_path.substr(0, last_slash + 1)
                          : "";

    std::stringstream ss;
    ss << file.rdbuf();
    std::string xml = ss.str();
    file.close();

    // Extract robot name
    result.model.name = extract_attr(xml, "robot", "name");

    // Parse all <link> elements
    parse_links(xml, result);

    // Parse all <joint> elements
    parse_joints(xml, result);

    if (result.model.links.empty()) {
      result.error = "No links found in URDF";
      return result;
    }

    // Build link index
    for (int i = 0; i < static_cast<int>(result.model.links.size()); ++i) {
      result.model.link_index[result.model.links[i].name] = i;
    }

    result.success = true;
    return result;
  }

private:
  // ── Minimal XML helpers (no external XML lib dependency) ─────────────

  /** Find all occurrences of a tag in the XML. Returns content between tags. */
  static std::vector<std::string> find_tags(const std::string &xml,
                                            const std::string &tag) {
    std::vector<std::string> results;
    std::string open = "<" + tag;
    size_t pos = 0;

    while ((pos = xml.find(open, pos)) != std::string::npos) {
      // Find the matching close tag, handling self-closing tags
      size_t tag_end = xml.find('>', pos);
      if (tag_end == std::string::npos)
        break;

      // Check for self-closing
      if (xml[tag_end - 1] == '/') {
        results.push_back(xml.substr(pos, tag_end - pos + 1));
        pos = tag_end + 1;
        continue;
      }

      // Find closing tag
      std::string close = "</" + tag + ">";
      size_t close_pos = xml.find(close, tag_end);
      if (close_pos == std::string::npos) {
        pos = tag_end + 1;
        continue;
      }

      results.push_back(xml.substr(pos, close_pos + close.size() - pos));
      pos = close_pos + close.size();
    }
    return results;
  }

  /** Extract attribute value from a tag string. */
  static std::string extract_attr(const std::string &tag_str,
                                  const std::string & /*tag*/,
                                  const std::string &attr) {
    std::string search = attr + "=\"";
    auto pos = tag_str.find(search);
    if (pos == std::string::npos)
      return "";
    pos += search.size();
    auto end = tag_str.find('"', pos);
    if (end == std::string::npos)
      return "";
    return tag_str.substr(pos, end - pos);
  }

  /** Extract attribute directly from content string. */
  static std::string get_attr(const std::string &content,
                              const std::string &attr) {
    return extract_attr(content, "", attr);
  }

  /** Parse "x y z" string to Vec3. */
  static math::Vec3 parse_vec3(const std::string &s) {
    math::Vec3 v;
    std::istringstream iss(s);
    iss >> v.x >> v.y >> v.z;
    return v;
  }

  /** Parse "r g b a" string to URDFColor. */
  static URDFColor parse_rgba(const std::string &s) {
    URDFColor c;
    std::istringstream iss(s);
    iss >> c.r >> c.g >> c.b >> c.a;
    return c;
  }

  /** Parse the first occurrence of a nested tag and return its content. */
  static std::string find_nested(const std::string &parent,
                                 const std::string &tag) {
    auto tags = find_tags(parent, tag);
    return tags.empty() ? "" : tags[0];
  }

  // ── Link Parsing ────────────────────────────────────────────────────

  static void parse_links(const std::string &xml, URDFLoadResult &result) {
    auto link_blocks = find_tags(xml, "link");

    for (const auto &block : link_blocks) {
      URDFLink link;
      link.name = get_attr(block, "name");
      if (link.name.empty())
        continue;

      // Parse visual
      std::string visual = find_nested(block, "visual");
      if (!visual.empty()) {
        parse_visual(visual, link);
      }

      // Parse inertial mass
      std::string inertial = find_nested(block, "inertial");
      if (!inertial.empty()) {
        std::string mass_tag = find_nested(inertial, "mass");
        std::string mass_val = get_attr(mass_tag, "value");
        if (!mass_val.empty()) {
          link.mass = std::stof(mass_val);
        }
      }

      result.model.links.push_back(link);
    }
  }

  static void parse_visual(const std::string &visual, URDFLink &link) {
    // Origin
    std::string origin_tag = find_nested(visual, "origin");
    if (!origin_tag.empty()) {
      std::string xyz = get_attr(origin_tag, "xyz");
      std::string rpy = get_attr(origin_tag, "rpy");
      if (!xyz.empty())
        link.visual_origin.xyz = parse_vec3(xyz);
      if (!rpy.empty())
        link.visual_origin.rpy = parse_vec3(rpy);
    }

    // Geometry
    std::string geom = find_nested(visual, "geometry");
    if (!geom.empty()) {
      parse_geometry(geom, link.visual_geom);
    }

    // Material color
    std::string material = find_nested(visual, "material");
    if (!material.empty()) {
      std::string color_tag = find_nested(material, "color");
      std::string rgba = get_attr(color_tag, "rgba");
      if (!rgba.empty()) {
        link.color = parse_rgba(rgba);
      }
    }
  }

  static void parse_geometry(const std::string &geom, URDFGeometry &g) {
    // Check for box
    std::string box = find_nested(geom, "box");
    if (!box.empty()) {
      g.type = URDFGeomType::Box;
      std::string size = get_attr(box, "size");
      if (!size.empty())
        g.size = parse_vec3(size);
      return;
    }

    // Check for cylinder
    std::string cyl = find_nested(geom, "cylinder");
    if (!cyl.empty()) {
      g.type = URDFGeomType::Cylinder;
      std::string r = get_attr(cyl, "radius");
      std::string l = get_attr(cyl, "length");
      if (!r.empty())
        g.radius = std::stof(r);
      if (!l.empty())
        g.length = std::stof(l);
      return;
    }

    // Check for sphere
    std::string sph = find_nested(geom, "sphere");
    if (!sph.empty()) {
      g.type = URDFGeomType::Sphere;
      std::string r = get_attr(sph, "radius");
      if (!r.empty())
        g.radius = std::stof(r);
      return;
    }

    // Check for mesh
    std::string mesh = find_nested(geom, "mesh");
    if (!mesh.empty()) {
      g.type = URDFGeomType::Mesh;
      g.mesh_filename = get_attr(mesh, "filename");
    }
  }

  // ── Joint Parsing ───────────────────────────────────────────────────

  static void parse_joints(const std::string &xml, URDFLoadResult &result) {
    auto joint_blocks = find_tags(xml, "joint");

    for (const auto &block : joint_blocks) {
      URDFJoint joint;
      joint.name = get_attr(block, "name");
      joint.type = get_attr(block, "type");
      if (joint.name.empty())
        continue;

      // Parent and child
      std::string parent = find_nested(block, "parent");
      std::string child = find_nested(block, "child");
      joint.parent_link = get_attr(parent, "link");
      joint.child_link = get_attr(child, "link");

      // Origin
      std::string origin_tag = find_nested(block, "origin");
      if (!origin_tag.empty()) {
        std::string xyz = get_attr(origin_tag, "xyz");
        std::string rpy = get_attr(origin_tag, "rpy");
        if (!xyz.empty())
          joint.origin.xyz = parse_vec3(xyz);
        if (!rpy.empty())
          joint.origin.rpy = parse_vec3(rpy);
      }

      // Axis
      std::string axis_tag = find_nested(block, "axis");
      if (!axis_tag.empty()) {
        std::string axis_xyz = get_attr(axis_tag, "xyz");
        if (!axis_xyz.empty())
          joint.axis = parse_vec3(axis_xyz);
      }

      result.model.joints.push_back(joint);
    }
  }
};

} // namespace loader
} // namespace qe
